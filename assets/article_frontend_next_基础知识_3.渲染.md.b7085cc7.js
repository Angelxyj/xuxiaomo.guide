import{_ as e,o as t,c as n,Q as r}from"./chunks/framework.25ff06b1.js";const m=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[{"level":2,"title":"一、渲染环境","slug":"一、渲染环境","link":"#一、渲染环境","children":[]},{"level":2,"title":"二、组件级别的渲染","slug":"二、组件级别的渲染","link":"#二、组件级别的渲染","children":[]},{"level":2,"title":"三、Server端的静态和动态渲染","slug":"三、server端的静态和动态渲染","link":"#三、server端的静态和动态渲染","children":[{"level":3,"title":"1. Static Rendering","slug":"_1-static-rendering","link":"#_1-static-rendering","children":[]},{"level":3,"title":"2. Dynamic Rendering","slug":"_2-dynamic-rendering","link":"#_2-dynamic-rendering","children":[]}]},{"level":2,"title":"四、Edge和Node.js运行时","slug":"四、edge和node-js运行时","link":"#四、edge和node-js运行时","children":[]}],"relativePath":"article/frontend/next/基础知识/3.渲染.md","filePath":"article/frontend/next/基础知识/3.渲染.md","lastUpdated":1707839101000}'),l={name:"article/frontend/next/基础知识/3.渲染.md"},a=r('<blockquote><p>渲染的理论</p></blockquote><h2 id="一、渲染环境" tabindex="-1">一、渲染环境 <a class="header-anchor" href="#一、渲染环境" aria-label="Permalink to &quot;一、渲染环境&quot;">​</a></h2><ul><li>client：用户客户端，即浏览器</li><li>server：服务端，可以是任何服务器</li></ul><h2 id="二、组件级别的渲染" tabindex="-1">二、组件级别的渲染 <a class="header-anchor" href="#二、组件级别的渲染" aria-label="Permalink to &quot;二、组件级别的渲染&quot;">​</a></h2><p>React18以前，使用React技术栈的系统渲染的主要方式还是完全依靠client端，Next.js提供了一种简便的方式将系统拆分为一个个pages，在server端预渲染为HTML并发送给client端进行hydrate，这种方式需要在client端请求额外的JavaScript代码实现HTML页面的交互效果。</p><p>现在，使用 <a href="https://beta.nextjs.org/docs/rendering/server-and-client-components" target="_blank" rel="noreferrer">Server and Client Components</a>，React可以在组件级别实现client和server两端的渲染，默认情况下，app目录下都是Server Components，便于我们在server端渲染组件，减少发送给client的JavaScript代码体积。</p><p>我们可以在一颗组件树中插入Server和Client Components，可以在Server Components中直接引入Client Components，在Client Components中使用Server Components时，需要使用clildren或props的方式。</p><p><img src="https://gitlab.com/lijing-2008/blogpic/-/raw/main/pictures/2023/02/1_7_29_53_component-tree.png" alt="Head File"></p><p>怎么决定什么时候用什么组件呢？</p><table><thead><tr><th style="text-align:left;">What do you need to do?</th><th style="text-align:left;">Server Component</th><th style="text-align:left;">Client Component</th></tr></thead><tbody><tr><td style="text-align:left;">Fetch data. <a href="https://beta.nextjs.org/docs/data-fetching/fetching" target="_blank" rel="noreferrer">Learn more</a>.</td><td style="text-align:left;">✅</td><td style="text-align:left;"><a href="https://beta.nextjs.org/docs/rendering/server-and-client-components#data-fetching" target="_blank" rel="noreferrer">⚠️</a></td></tr><tr><td style="text-align:left;">Access backend resources (directly)</td><td style="text-align:left;">✅</td><td style="text-align:left;">❌</td></tr><tr><td style="text-align:left;">Keep sensitive information on the server (access tokens, API keys, etc)</td><td style="text-align:left;">✅</td><td style="text-align:left;">❌</td></tr><tr><td style="text-align:left;">Keep large dependencies on the server / Reduce client-side JavaScript</td><td style="text-align:left;">✅</td><td style="text-align:left;">❌</td></tr><tr><td style="text-align:left;">Add interactivity and event listeners (<code>onClick()</code>, <code>onChange()</code>, etc)</td><td style="text-align:left;">❌</td><td style="text-align:left;">✅</td></tr><tr><td style="text-align:left;">Use State and Lifecycle Effects (<code>useState()</code>, <code>useReducer()</code>, <code>useEffect()</code>, etc)</td><td style="text-align:left;">❌</td><td style="text-align:left;">✅</td></tr><tr><td style="text-align:left;">Use browser-only APIs</td><td style="text-align:left;">❌</td><td style="text-align:left;">✅</td></tr><tr><td style="text-align:left;">Use custom hooks that depend on state, effects, or browser-only APIs</td><td style="text-align:left;">❌</td><td style="text-align:left;">✅</td></tr><tr><td style="text-align:left;">Use <a href="https://reactjs.org/docs/components-and-props.html#function-and-class-components" target="_blank" rel="noreferrer">React Class components</a></td><td style="text-align:left;">❌</td><td style="text-align:left;">✅</td></tr></tbody></table><h2 id="三、server端的静态和动态渲染" tabindex="-1">三、Server端的静态和动态渲染 <a class="header-anchor" href="#三、server端的静态和动态渲染" aria-label="Permalink to &quot;三、Server端的静态和动态渲染&quot;">​</a></h2><p>除了客户端和服务端渲染React组件外，Next.js提供服务端的Static和Dynamic两种可选渲染方式来进行优化</p><h3 id="_1-static-rendering" tabindex="-1">1. Static Rendering <a class="header-anchor" href="#_1-static-rendering" aria-label="Permalink to &quot;1. Static Rendering&quot;">​</a></h3><p>预渲染是在Build的时候，结果将被缓存下来，后续调用将被重复利用，缓存结果也可以被重新验证（比如可以设置一个时间，每隔一段时间重新获取一次结果），这个思想等同于等同于SSG(Static Site Generation)和ISR(Incremental Static Regeneration)。</p><p>客户端组件和服务端组件静态渲染时的不同点：</p><ul><li>Clinet Components：HTML和JSON预渲染并缓存到server，然后缓存结果发送到clinet进行hydrate</li><li>Server Components：通过React在服务端渲染，他们的payload被用来生成HTML，同样也被渲染的payload用来hydrate客户端上的组件，结果是客户端不在需要重新获取JavaScript</li></ul><h3 id="_2-dynamic-rendering" tabindex="-1">2. Dynamic Rendering <a class="header-anchor" href="#_2-dynamic-rendering" aria-label="Permalink to &quot;2. Dynamic Rendering&quot;">​</a></h3><p>客户端组件和服务端组件都是在有请求时在服务端进行渲染的，渲染的结果不会进行缓存。等同于Next.js之前版本中的 <a href="https://nextjs.org/docs/api-reference/data-fetching/get-server-side-props" target="_blank" rel="noreferrer">Server-Side Rendering (<code>getServerSideProps()</code>)</a></p><h2 id="四、edge和node-js运行时" tabindex="-1">四、Edge和Node.js运行时 <a class="header-anchor" href="#四、edge和node-js运行时" aria-label="Permalink to &quot;四、Edge和Node.js运行时&quot;">​</a></h2><p>在服务端，有两种运行时可以渲染你的页面</p><ul><li>Node.js Runtime：默认运行时，可使用所有的node.js api以及生态系统中的包库</li><li>Edge Runtime：基于Web APIs，只能使用服务于Edge Runtime的包</li></ul><p>两种运行时都支持streaming data（来自server），依赖于你部署的环境设施</p>',22),i=[a];function d(s,o,c,g,p,h){return t(),n("div",null,i)}const y=e(l,[["render",d]]);export{m as __pageData,y as default};
