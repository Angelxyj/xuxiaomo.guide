import{_ as s,o as a,c as n,Q as e}from"./chunks/framework.ab7e7ee0.js";const m=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[{"level":2,"title":"一、useCallback","slug":"一、usecallback","link":"#一、usecallback","children":[]},{"level":2,"title":"二、useMemo","slug":"二、usememo","link":"#二、usememo","children":[]},{"level":2,"title":"三、等价转换","slug":"三、等价转换","link":"#三、等价转换","children":[]}],"relativePath":"article/frontend/react/Hooks详解/1.useCallback和useMemo.md","filePath":"article/frontend/react/Hooks详解/1.useCallback和useMemo.md","lastUpdated":1707839101000}'),l={name:"article/frontend/react/Hooks详解/1.useCallback和useMemo.md"},o=e(`<p><strong>先上结论</strong></p><blockquote><ul><li><p>如果想传递函数给子组件，请使用<code>useCallback</code>包裹后再传，避免子组件不必要的重复渲染，前提是子组件使用<code>memo</code>函数包裹</p></li><li><p>如果想进行大量计算，请使用<code>useMemo</code>包裹计算逻辑后再使用其返回值，避免不必要的大量重复相同计算</p></li><li><p>如果想传递对象给子组件，请使用<code>useMemo</code>包裹后再传，避免子组件不必要的重复渲染，前提是子组件使用<code>memo</code>函数包裹</p></li></ul></blockquote><p>问题：<code>React</code>组件在<code>state</code>和<code>props</code>发生变化的时候都会从头到尾重新渲染一次，而在次渲染的时候，里面普通定义的函数、对象都会重新创建一次</p><h2 id="一、usecallback" tabindex="-1">一、useCallback <a class="header-anchor" href="#一、usecallback" aria-label="Permalink to &quot;一、useCallback&quot;">​</a></h2><p><code>useCallback</code>实际目的是为了进行性能的优化，如何进行性能优化呢？</p><p><code>useCallback</code>会返回一个函数的<code>memoized</code>记忆值，在依赖不变的情况下，多次定义的时候返回的值是相同的</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">memoizedCallback</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">useCallback</span><span style="color:#E1E4E8;">( () </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">doSomething</span><span style="color:#E1E4E8;">(a, b)</span></span>
<span class="line"><span style="color:#E1E4E8;">}, [a, b])</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">memoizedCallback</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">useCallback</span><span style="color:#24292E;">( () </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">doSomething</span><span style="color:#24292E;">(a, b)</span></span>
<span class="line"><span style="color:#24292E;">}, [a, b])</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>对于定义一个函数本身来说，使用和不使用并不会带来性能优化，其优化的点在于，将把这个函数传递给子组件时，如果该函数不发生变化，那么子组件不会重新渲染！这就是性能优化的点，我们使用<code>useCallback</code>的目的是不希望子组件进行多次渲染，并不是为了函数进行缓存。</p><h2 id="二、usememo" tabindex="-1">二、useMemo <a class="header-anchor" href="#二、usememo" aria-label="Permalink to &quot;二、useMemo&quot;">​</a></h2><p><code>useMemo</code>实际目的是也为了进行性能的优化，如何进行性能优化呢？</p><p><code>useMemo</code>返回的也是一个 <code>memoized</code>（记忆的）值，在依赖不变的情况下，多次定义的时候返回的值是相同的</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">memoizedValue</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">useMemo</span><span style="color:#E1E4E8;">( () </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">computeValue</span><span style="color:#E1E4E8;">(a, b)</span></span>
<span class="line"><span style="color:#E1E4E8;">}, [a, b])</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">memoizedValue</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">useMemo</span><span style="color:#24292E;">( () </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">computeValue</span><span style="color:#24292E;">(a, b)</span></span>
<span class="line"><span style="color:#24292E;">}, [a, b])</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>如果不使用<code>useMemo</code>，在进行大量计算操作时，每次渲染组件都会重新计算一次，使用了<code>useMemo</code>后，如果依赖不变，就不会重新计算！这就是优化的点，同时，对子组件传递相同内容的对象时，使用<code>useMemo</code>也可以进行性能优化。</p><div class="language-jsx vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">info</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">useMemo</span><span style="color:#E1E4E8;">( () </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> ({</span></span>
<span class="line"><span style="color:#E1E4E8;">  name: </span><span style="color:#9ECBFF;">&#39;coder&#39;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  age: </span><span style="color:#79B8FF;">18</span></span>
<span class="line"><span style="color:#E1E4E8;">}))</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 传递给子组件,在父组件发生重新渲染时，子组件不会重新渲染</span></span>
<span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#79B8FF;">Son</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">info</span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;">{info}/&gt;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">info</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">useMemo</span><span style="color:#24292E;">( () </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> ({</span></span>
<span class="line"><span style="color:#24292E;">  name: </span><span style="color:#032F62;">&#39;coder&#39;</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">  age: </span><span style="color:#005CC5;">18</span></span>
<span class="line"><span style="color:#24292E;">}))</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 传递给子组件,在父组件发生重新渲染时，子组件不会重新渲染</span></span>
<span class="line"><span style="color:#24292E;">&lt;</span><span style="color:#005CC5;">Son</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">info</span><span style="color:#D73A49;">=</span><span style="color:#24292E;">{info}/&gt;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h2 id="三、等价转换" tabindex="-1">三、等价转换 <a class="header-anchor" href="#三、等价转换" aria-label="Permalink to &quot;三、等价转换&quot;">​</a></h2><p>从上面可以看出，如果<code>useMemo</code>返回一个函数，那和<code>useCallback</code>其实是一样的</p><p><code>useCallback(fn, deps)</code>和<code>useMemo( ()=&gt;fn, deps)</code>是等价的！</p>`,17),p=[o];function c(t,r,i,d,E,y){return a(),n("div",null,p)}const b=s(l,[["render",c]]);export{m as __pageData,b as default};
